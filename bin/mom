#!/usr/bin/bash

ABOUT='MOM - Media Operation/Manipulation
A collection of media operation/manipulation scripts.'

. sss

actionInfo nometa M 'no[M]eta' 'remove metadata from audio files'
nometaParams=(
	src '' '$e\.(flac|wma|m4a|mp3|opus)' 'Audio file/dir to strip metadata from'
	dst '?' '.+' 'Put results into (default=replace original)')
nometa() {
	if [[ -d $src ]]; then
		local CWD=$PWD
		cd "$src"
		for f in *; do
			[[ $f =~ \.(flac|wma|m4a|mp3|opus)$ ]] || continue
			src=$f
			nometa
		done
		cd "$CWD"
	else
		[[ $dst ]] || local dst=/tmp/ defaultDst=true

		[[ -d $dst ]] && local dst=${dst%/}/${src##*/}
		if exec ffmpeg -v error -i "$src" -map_metadata -1 -map a -c copy "$dst"; then
			[[ -z $defaultDst ]] || exec mv "$dst" "$src"
		fi
	fi
}

# TODO: make as option before conversion / make a cmd pipeline, not a separate command â†’ compose
# scripts to generate options
# Do as batch operations - option for loading input/output
# option for additional options / envvars
# cut() {

# }

actionInfo convert 'convert audio files to opus'
convertParams=( # TODO: opt for ignoring low qual mp3
	NO_RM '-R' '' 'Prevent source file removal'
	bitrate '-b' '[0-9]+' 'Output bitrate in kbps (default=96)'
	src '+' '$f\.(flac|wma|m4a|mp3)' 'File to convert'
	dst '?' '$e\.opus' 'Output file (default=`$src.opus`, deletes `$src`)')
convert() {
	[[ $bitrate ]] ||
		[[ $f =~ \.(flac|wav)$ || $(
			ffprobe "$f" |& sed -n 's/.*bitrate: \([0-9]\+\) .*/\1/p'
		) > 192 ]] && local brate=128 || local bitrate=96
	[[ -f $dst && ${#src[@]} -gt 1 ]] && log Warn ': cannot specify multiple src and a file dst'

	for src in "${src[@]}"; do
		if [[ -z $dst ]]; then
			local out=${src%.*}.opus defaultDst=true
		else
			[[ -d $dst ]] && local out="$dst/${src/*\//}" || local out=$dst
			defaultDst=
		fi
		if exec ffmpeg -v error -i "$src" -map_metadata -1 -map a -b:a ${bitrate}k "$out"; then
			[[ -z $defaultDst || $NO_RM ]] || exec rm "$src"
		fi
	done
}

actionInfo subtitles t 'sub[t]itles' 'convert mp4 with srt to mkv'
subtitlesParams=(
	NO_RM '-R' '' 'Prevent source file removal'
	NO_DEF_CHANGE '-D' '' 'Prevent default-subs change (changes to first subs by default)'
	lang '-l' '[a-z]+' 'Language in order of provided subtitles (default=eng)'
	# encoding '-e' "${REGEX[dashvar]}" 'wanted final encoding (requires `enca`; default=UTF-8)'
	subs '*' '$f\.srt' 'Subtitles to add (default=*.srt)'
	vid '?' '$f\.(mp4|mkv)' 'Source video file (default=first of `*.mp4`,`*.mkv`)'
	dst '?' '$f\.mkv' 'Output file (default=`$vid.mkv`)')
# subtitle format from windows transcoding using `enca` package
subtitles() {
	if [[ -z $subs ]]; then
		if [[ -z $vid ]]; then
			local subs=(*.srt)
		else
			local match=${vid@L}
			match=${match%.*}.srt
			for f in *.srt; do
				[[ ${f@L} == "$match" ]] && local subs=$f && break
			done
		fi
		[[ -z $subs ]] && log Warn " - no match for '$match'" && return
	fi

	[[ $vid == *.mkv && ! -f $vid && -z $dst ]] && local dst=$vid && vid=
	if [[ -z $vid ]]; then
		local match=${subs@L}
		match=${match%.*}.
		for f in *.mp4 *.mkv; do
			[[ ${f@L} == "$match"* ]] && local vid=$f && break
		done
		[[ -z $vid ]] && log Warn " - no match for '$match'" && return
	fi

	[[ $lang ]] || local lang=eng
	# [[ $encoding ]] || local encoding=UTF-8
	local opts=(-v error)
	for sub in "${subs[@]}"; do
		# if [[ $(file "$sub" -b) =~ ([^ ]+)\ text && ${BASH_REMATCH[1]} != $encoding ]]; then
		# enca "$sub" -x "$encoding"
		# fi
		opts+=(-i "$sub")
	done
	opts+=(-i "$vid" -map s -map ${#subs[@]} -c copy)
	declare -i i=0
	for sub in "${subs[@]}"; do
		[[ ${lang[$i]} ]] && opts+=(-metadata:s:s:$i language=${lang[$i]})
		i+=1
	done
	[[ $NO_DEF_CHANGE ]] || opts+=(-disposition:s:0 default)
	[[ -z $dst ]] && local dst=${vid%.*}.mkv
	opts+=("/tmp/${dst##*/}")

	exec ffmpeg "${opts[@]}" &&
		exec mv "/tmp/${dst##*/}" "$dst" && [[ -z $NO_RM ]] && exec rm "${subs[@]}" "$vid"
}

actionInfo play 'select and play a song/dir using mpv'
playParams=(
	randomizer '-R' '[deo]' 'd=disable; e=enable (default); o=once, then just play'
	NO_LOOP '-L' '' 'Do not loop playlist'
	src '' '$e' 'Play file/dir')
declare -A playBuilder=([src]=pickSong)
pickSong() {
	declare -n _choice=$1
	_choice="$({
		find ~/Music/* -type d
		find ~/Music/Songs -type f
	} | rofi -dmenu -i -p "$4" -theme-str 'window {width: 50%;}')"
}
play() {
	local playlistFile=/tmp/my/song
	local cmd=(mpv --no-audio-display --msg-level=all=no --playlist=$playlistFile)
	((NO_LOOP)) || cmd+=(--loop-playlist)
	pkill -f "${cmd[*]::2}"

	if [[ -f $src ]]; then
		exec echo "$src" > $playlistFile
		cmd+=(--playlist-start=0)
		src=${src%/*}
	elif [[ -f $playlistFile ]]; then
		exec rm "$playlistFile"
	fi

	case "${randomizer:-e}" in
		d) exec echo "$src" >> "$playlistFile" ;;
		o) exec fd '' -t f "$src" | sort -R >> "$playlistFile" ;;
		e) exec echo "$src" >> "$playlistFile" && cmd+=(--shuffle) ;;
	esac

	exec "${cmd[@]}" & disown >/dev/null
	sleep 1 && exec rm "$playlistFile"
	return 0
}

actionInfo compare C "play randomized files and reveal user's pick"
compareParams=(files '+' '$f' 'Files to compare')
compare() {
	declare -i c=${#files[@]}*${#files[@]}+1 i j
	for i in ${!files[@]}; do # absolute path for `ln -s`
		[[ ${files[$i]} == /* ]] || files[$i]="$PWD/${files[$i]}"
	done
	while ((c-- > 0)); do
		i=$RANDOM%${#files[@]}
		j=$RANDOM%${#files[@]}
		if ((i != j)); then
			x=${files[$i]}
			files[i]=${files[$j]}
			files[j]=$x
		fi
	done

	for i in ${!files[@]}; do
		exec ln -sf "${files[$i]}" /tmp/mediacmp$((i + 1))
		exec ${TERMINAL:-xterm} echo $((i + 1))\; mpv --no-audio-display /tmp/mediacmp$((i + 1)) &
		sleep 1
	done
	read -p "pick [1-${#files[@]}]: " best
	declare -i best=($best)
	for i in ${best[@]}; do
		echo "${files[$((i - 1))]#$PWD/}"
	done
	declare -i i=${#files[@]}
	while ((--i)); do
		exec rm /tmp/mediacmp$i
	done
}

main "$@"
