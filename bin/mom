#!/usr/bin/bash

ABOUT='MOM - Media Operation/Manipulation
A collection of media operation/manipulation scripts.'

. sss

actionInfo nometa M 'no[M]eta' 'remove metadata from audio files'
nometaParams=(
	src '' "${REGEX[file]}\.(flac|wma|m4a|mp3|opus)" 'Audio file/dir to strip metadata from'
	dst '?' "${REGEX[file]}" 'Put results into (default=replace original)')
declare -A nometaBuilder=([src]=pickFilesOrDir [dst]=pickFilesOrDir)
nometa() {
	if [[ -d $src ]]; then
		local CWD=$PWD
		cd "$src"
		for f in *; do
			[[ $f =~ \.(flac|wma|m4a|mp3|opus)$ ]] || continue
			src=$f
			nometa
		done
		cd "$CWD"
	else
		[[ $dst ]] || local dst=/tmp/ defaultDst=true

		[[ -d $dst ]] && local dst=${dst%/}/${src##*/}
		if exec ffmpeg -v error -i "$src" -map_metadata -1 -map a -c copy "$dst"; then
			[[ -z $defaultDst ]] || exec mv "$dst" "$src"
		fi
	fi
}

# TODO: make as option before conversion / make a cmd pipeline, not a separate command â†’ compose
# scripts to generate options
# Do as batch operations - option for loading input/output
# option for additional options / envvars
# cut() {

# }

actionInfo convert 'convert audio files to opus'
convertParams=(
	NO_RM '-R' '' 'Prevent source file removal'
	bitrate '-b' '[0-9]+' 'Output bitrate in kbps (default=96)'
	src '' "${REGEX[file]}\.(flac|wma|m4a|mp3)" 'File to convert'
	dst '?' "${REGEX[file]}\.opus" 'Output file (default=`$src.opus`, deletes `$src`)')
convert() {
	[[ $bitrate ]] ||
		# [[ $f =~ \.(flac|wav)$ || $(
		# 	ffprobe "$f" |& sed -n 's/.*bitrate: \([0-9]\+\) .*/\1/p'
		# ) > 192 ]] && local brate=128 ||
		local bitrate=96
	[[ $dst ]] || local dst=${src%.*}.opus defaultDst=true
	if exec ffmpeg -v error -i "$src" -map_metadata -1 -map a -b:a ${bitrate}k "$dst"; then
		[[ -z $defaultDst || $NO_RM ]] || exec rm "$src"
	fi
}

actionInfo subtitles t 'sub[t]itles' 'convert mp4 with srt to mkv'
subtitlesParams=(
	NO_RM '-R' '' 'Prevent source file removal'
	NO_DEF_CHANGE '-D' '' 'Prevent default-subs change (changes to first subs by default)'
	lang '-l' '[a-z]+' 'Language in order of provided subtitles (default=eng)'
	# encoding '-e' "${REGEX[dashvar]}" 'wanted final encoding (requires `enca`; default=UTF-8)'
	subs '*' '.*\.srt' 'Subtitles to add (default=*.srt)'
	vid '?' '.*\.(mp4|mkv)' 'Source video file (default=first of `*.mp4`,`*.mkv`)'
	dst '?' '.*\.mkv' 'Output file (default=`$vid.mkv`)')
# subtitle format from windows transcoding using `enca` package
subtitles() {
	if [[ -z $subs ]]; then
		if [[ -z $vid ]]; then
			local subs=(*.srt)
		else
			local match=${vid@L}
			match=${match%.*}.srt
			for f in *.srt; do
				[[ ${f@L} == "$match" ]] && local subs=$f && break
			done
		fi
		[[ -z $subs ]] && log Warn " - no match for '$match'" && return
	fi

	[[ $vid == *.mkv && ! -f $vid && -z $dst ]] && local dst=$vid && vid=
	if [[ -z $vid ]]; then
		local match=${subs@L}
		match=${match%.*}.
		for f in *.mp4 *.mkv; do
			[[ ${f@L} == "$match"* ]] && local vid=$f && break
		done
		[[ -z $vid ]] && log Warn " - no match for '$match'" && return
	fi

	[[ $lang ]] || local lang=eng
	# [[ $encoding ]] || local encoding=UTF-8
	local opts=(-v error)
	for sub in "${subs[@]}"; do
		# if [[ $(file "$sub" -b) =~ ([^ ]+)\ text && ${BASH_REMATCH[1]} != $encoding ]]; then
		# enca "$sub" -x "$encoding"
		# fi
		opts+=(-i "$sub")
	done
	opts+=(-i "$vid" -map s -map ${#subs[@]} -c copy)
	declare -i i=0
	for sub in "${subs[@]}"; do
		[[ ${lang[$i]} ]] && opts+=(-metadata:s:s:$i language=${lang[$i]})
		i+=1
	done
	[[ $NO_DEF_CHANGE ]] || opts+=(-disposition:s:0 default)
	[[ -z $dst ]] && local dst=${vid%.*}.mkv
	opts+=("/tmp/${dst##*/}")

	exec ffmpeg "${opts[@]}" &&
		exec mv "/tmp/${dst##*/}" "$dst" && [[ -z $NO_RM ]] && exec rm "${subs[@]}" "$vid"
}

actionInfo play 'select and play a song/dir using mpv'
playParams=(
	dirrnd '-d' '' 'Use randomization by dir structure instead of mpv'
	NO_RND '-R' '' 'Do not randomize playlist (XOR with -i)'
	NO_LOOP '-L' '' 'Do not loop playlist'
	src '' "${REGEX[file]}" 'Play file/dir')
declare -A playBuilder=([src]=pickSong)
pickSong() {
	declare -g $1="$({
		find ~/Music/* -type d
		find ~/Music/Songs -type f
	} | rofi -dmenu -i -p "$4" -theme-str 'window {width: 50%;}')"
}
play() {
	local cmd=(mpv --no-audio-display --msg-level=all=no)
	pkill -f "${cmd[*]::2}"
	if [[ $dirrnd ]]; then
		[[ -f $src ]] && exec "${cmd[@]}" "$src" && return 0

		src=("$src"/*)
		while (($? == 0)); do
			local f="${src[$((RANDOM % ${#src[@]}))]}"
			while [[ -d $f ]]; do
				local d=("$f"/*)
				f="${d[$((RANDOM % ${#d[@]}))]}"
			done
			exec "${cmd[@]}" "$f"
		done
	else
		cmd+=(--playlist=/tmp/song)
		[[ $NO_RND ]] || cmd+=(--shuffle)
		[[ $NO_LOOP ]] || cmd+=(--loop-playlist)
		exec echo "$src" > /tmp/song
		[[ -f $src ]] && echo "${src%/*}" >> /tmp/song && cmd+=(--playlist-start=0)
		exec "${cmd[@]}"
	fi
	return 0
}

actionInfo compare C "play randomized files and reveal user's pick"
compareParams=(files '+' "${REGEX[file]}" 'Files to compare')
declare -A compareBuilder=([files]=pickFiles)
compare() {
	declare -i c=${#files[@]}*${#files[@]}+1 i j
	for i in ${!files[@]}; do # absolute path for `ln -s`
		[[ ${files[$i]} == /* ]] || files[$i]="$PWD/${files[$i]}"
	done
	while ((c-- > 0)); do
		i=$RANDOM%${#files[@]}
		j=$RANDOM%${#files[@]}
		if ((i != j)); then
			x=${files[$i]}
			files[i]=${files[$j]}
			files[j]=$x
		fi
	done

	for i in ${!files[@]}; do
		exec ln -sf "${files[$i]}" /tmp/mediacmp$((i + 1))
		exec ${TERMINAL:-xterm} echo $((i + 1))\; mpv --no-audio-display /tmp/mediacmp$((i + 1)) &
		sleep 1
	done
	read -p "pick [1-${#files[@]}]: " best
	declare -i best=($best)
	for i in ${best[@]}; do
		echo "${files[$((i - 1))]#$PWD/}"
	done
	declare -i i=${#files[@]}
	while ((--i)); do
		exec rm /tmp/mediacmp$i
	done
}

main "$@"
