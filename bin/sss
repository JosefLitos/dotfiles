#!/usr/bin/bash

declare -A ACTION_INFO=()
declare -a ACTION_ORDER=()
ALIGNER=0

#######################################
# Register fn/action docs and for execution
# Arguments:
#   name: name of the function
#   key?: a unique one-letter shortcut for calling, or '' for no shortcut
#   helpsig?: function name displayed in help (with bracket-highlighted key)
#   help: help text
#######################################
actionInfo() {
	local name=$1 key helpsig help=${!#}
	(($# > 2)) && key=$2 || key=${name::1}
	if (($# > 3)); then
		helpsig=$3
	else
		[[ $key ]] && helpsig="[$key]${name:1}" || helpsig=$name
	fi
	[[ $key ]] && ACTION_INFO[$key]="$name"
	((ALIGNER < ${#helpsig})) && ALIGNER=${#helpsig}
	ACTION_INFO[$name]="$helpsig $help"
	ACTION_ORDER+=($name)
}

declare -Ai SSS_OPTS=( # options for configuring SSS behaviour - changed by `define` action
	[cli]=0          # user runs in CLI (1) or TUI (0) mode
	[tui]=0          # TUI mode should be run after parsing args/CLI
	[picker]=0       # missing arguments can be picked through user input
	[optArgPicker]=0 # optional arguments can be picked
	[guiPicker]=0    # pickers prompt user with GUI (1) or use TUI (0)
	[dryRun]=0       # fake external command execution (`exec` returns success)
	[log]=2          # current log level
)
[[ $# == 0 && -t 0 ]] && SSS_OPTS[tui]=1 || SSS_OPTS[cli]=1
[[ -t 0 ]] || SSS_OPTS[guiPicker]=1
declare -A LOG_LEVELS=([quiet]=0 [error]=1 [warn]=2 [warning]=2 [info]=3 [debug]=4)
LOG_NAMES=(quiet error warn info debug)

declare -A SCRIPT_OPTS=( # options for additional script configuration/behavioural changes
	[about]=      # script description
	[exitFn]=exit # when all actions were executed; (commit/rollback) - should never return
	# set to main registered action if script is a single command - actions act as builders
	# you can also change other actions' params at runtime → dynamic configuration
	# builder example: --builder init1 --builderOption --builder init2 'default action arg'
	[defAction]=unknown # when no other action matches args, actionInfo register optional
	[defActionRep]=0    # default action can be called multiple times
	[optPrefix]='-{,2}'   # regex for required cli long name format
)

#######################################
# Print given message with context of current action and log level
# Arguments:
#   logLvl: one of ${!LOG_LEVELS[@]}, determines message importance
#   msg: message to print with context, ignored when SSS_OPTS[log]<logLvl
# Returns:
#   success when message was printed, exits if Warning in cli mode or Error are reported
#######################################
log() {
	logLvl=${LOG_LEVELS[${1,}]:-$1}
	if ((SSS_OPTS[log] >= logLvl)); then
		local name=${LOG_NAMES[$logLvl]}
		echo "${name^}: $action$2" 1>&2
	fi
	((SSS_OPTS[cli] <= 0 && logLvl > 1 || logLvl > 2)) || ${SCRIPT_OPTS[exitFn]} 1
	((SSS_OPTS[log] >= logLvl))
}

exec() {
	((SSS_OPTS[log] > 2)) && log Info "\$> $*"
	((SSS_OPTS[dryRun])) && return 0
	[[ ${!#} == \& ]] && { "${@:1:$((${#} - 1))}" & } || "$@"
}
# TODO: config as toml (action as sections) or bash map <action>ParamDefaults
actionInfo define D 'set script-processing options'
defineParams=( # TODO: consider a builtin action config loader (bash script)
	dry 'd?' '' 'Disable actual commands execution'
	tui 't?' '' 'Enter TUI mode after cli is parsed'
	pick 'p?' '' 'Enable picker in cli'
	gui 'g?' '' 'Enable gui picker'
	opt 'o?' '' 'Enable picker for optional arguments'
	lvl 'l?' '([0-9]+|[Ee]rr(or)?|[Ww]arn(ing)?|[Ii]nfo|[Dd]ebug)?'
	'Depth of logging (default=Warn=2), or multiple mentions for setting by count'
)
define() {
	if ((dry)); then
		((dry < 0))
		SSS_OPTS[dryRun]=$?
	fi
	if ((tui)); then
		((tui < 0))
		SSS_OPTS[tui]=$?
	fi
	if ((pick)); then
		((pick < 0))
		SSS_OPTS[picker]=$?
	fi
	if ((gui)); then
		((gui < 0))
		SSS_OPTS[guiPicker]=$?
	fi
	if ((opt)); then
		((opt < 0))
		SSS_OPTS[optArgPicker]=$?
	fi
	if [[ $lvl ]]; then
		[[ $lvl == -* ]] && ((SSS_OPTS[log] += lvl)) || SSS_OPTS[log]=${LOG_LEVELS[${lvl^}]:-$lvl}
	fi
}

main() {
	if ((SSS_OPTS[cli])); then
		while (($#)); do
			parseAction "$@"
			shift $?
		done
		((SSS_OPTS[tui])) || quit
		SSS_OPTS[cli]=0
	fi

	SSS_OPTS[picker]=1
	while :; do
		if ((SSS_OPTS[optArgPicker])); then
			read -rp 'Choose action (+opts): ' line
		else
			read -rp 'Choose action: ' -n 1 line
			echo
		fi
		if [[ ${line%% *} == ? || '-' =~ ^$OPT_PREFIX_RE$ ]]; then
			parseAction -$line
		elif [[ '--' =~ ^$OPT_PREFIX_RE$ ]]; then
			parseAction --$line
		else
			parseAction $line
		fi
		logLvl=100
	done
}

# set all required variables and call action
parseAction() {
	declare -i argc=$#
	# get action name
	if [[ $1 =~ ^($OPT_PREFIX_RE)([^-][^=]+)(=.*)?$ && ${ACTION_INFO["${BASH_REMATCH[2]}"]} ]]; then
		local action=${BASH_REMATCH[2]} actionArg=${BASH_REMATCH[3]:1}
	elif [[ $1 =~ ^-([^-])(.*)$ ]]; then
		local action=${ACTION_INFO[${1:1:1}]} actionArg=${BASH_REMATCH[2]:+-${BASH_REMATCH[2]}}
	fi
	if [[ $action ]]; then
		[[ $actionArg ]] && set -- "$actionArg" || shift
	else
		action=${SCRIPT_OPTS[defAction]} actionArg=
	fi

	declare -n sigs=${action}Params
	declare -i sigN=${#sigs[@]}
	((sigN % 4)) && log Error "Params definition is missing $((4 - sigN % 4)) fields" && return
	local i # not declare -i to not preset default value to 0, for option handling

	# distinguish options and args
	declare -A ids=() # opt/arg identifiers
	local argPos
	for ((i = 0; i < sigN; i += 4)); do
		local sign=${sigs[i + 1]}
		ids["${sigs[$i]}"]=$i
		if [[ $sign == ?[?*!+] ]]; then # opts with quantifier - 1 or many
			[[ $sign != _? ]] && ids["${sign::1}"]=$i
			[[ $sign == ?[+!] ]] && argPos=${argPos:-$i} # args with quantifier - 1 or many
		elif [[ $sign == [?*!+] ]]; then
			argPos=${argPos:-$i} # positional args, with long name only
		fi                    # NOTE: shortname not allowed to be not too complex for the user
	done
	((SSS_OPTS[log] > 3)) && declare -p ids >&2

	declare -n builder=${action}Builder
	# get options
	while [[ $1 ]]; do
		# parse option prefix
		[[ $1 == -- ]] && shift && break
		local i= arg= optCnt=+
		if [[ $1 =~ ^($OPT_PREFIX_RE)([^-][^=]+)(=.+)?$ && -z $actionArg ]]; then # full option name
			i=${ids["${BASH_REMATCH[2]}"]}
			[[ $i ]] && arg=${BASH_REMATCH[3]:1}
		fi
		if [[ !$i && $1 =~ ^[+-]([^-+])(.+)?$ ]]; then # short option -o(Val)?
			[[ $1 == +* ]] && optCnt=-                    # +o means toggle off → -=
			i=${ids["${BASH_REMATCH[1]}"]}
			arg=${BASH_REMATCH[2]}
			while [[ $i && $arg ]]; do # -oooo toggle opts in succession
				local reg=${sigs[i + 2]}
				if [[ $reg ]]; then # opt arg (last) or no arg required
					[[ '' =~ ^$reg$ ]] && ! argMatch "${arg:-$2}" || break
				fi
				declare -i ${sigs[$i]//-/_}+=${optCnt}1 # preserve amount of that no-arg option's use
				i=${ids[${arg::1}]} arg=${arg:1}
			done
		fi
		[[ $i ]] && shift || break

		# parse option arg / set value
		local varName=${sigs[$i]//-/_} reg=${sigs[i + 2]}
		if [[ $reg ]]; then # requires arg
			if [[ $arg || $1 ]] && argMatch "${arg:-$1}"; then
				declare -a $varName
				declare -n varName
				varName+=("${arg:-$1}")
				declare +n varName
				[[ $arg ]] || shift
			elif [[ -z $arg && '' =~ ^$reg$ ]]; then # no arg, allows '' → number of uses as value
				declare -i $varName+=${optCnt}1
			else
				if ((SSS_OPTS[picker])) && [[ -z $arg && ${sigs[i + 1]} != ?[+!] ]]; then
					declare -a $varName # picker for options
					log Debug ".$varName << ${builder[$varName]:-pickAny}"
					${builder[$varName]:-pickAny} "${sigs[@]:i:4}"
				fi

				[[ -z ${!varName} ]] && log Error " - Option argument expected, got '${arg:-$1}':
$(paramHelp $action $((i / 4)))" && return
			fi
		else
			if [[ $arg ]]; then
				log Error " - Unexpected option argument '$arg':
$(paramHelp $action $((i / 4)))" && return
			else
				declare -i $varName+=${optCnt}1
			fi
		fi
	done
	unset ids arg

	[[ $actionArg && $1 ]] && set -- "${1#-}"

	# get arguments
	i=$argPos
	unset argPos
	for ((i; i < sigN; i += 4)); do
		local varName=${sigs[$i]} sign=${sigs[i + 1]} reg=${sigs[i + 2]}
		[[ $sign == ?[?*] ]] && continue # option between arguments
		if [[ ${#sign} == 1 && $# -gt 0 ]] && argMatch "$1"; then
			if [[ $sign == [+*] ]]; then # param is a list
				declare -a $varName
				declare -n args=$varName
				while [[ $# -gt 0 ]] && argMatch "$1"; do
					args+=("$1")
					shift
				done
			else
				declare $varName="$1" # single argument expected
				shift
			fi
			continue
		elif [[ ! ${!varName} ]]; then
			if ((SSS_OPTS[picker])); then # picker for optional args || arg required
				if ((SSS_OPTS[optArgPicker])) || [[ ${sign:0-1} == [+!] ]]; then
					log Debug ".$varName << ${builder[$varName]:-pickAny}"
					declare -a $varName # prepare variable as local
					${builder[$varName]:-pickAny} "${sigs[@]:i:4}"
				fi
			fi
			[[ ! ${!varName} && ${sign:0-1} == [+!] ]] && log Error " - Argument expected:
$(paramHelp $action $((i / 4)))" && return
		fi
	done
	declare +n args builder
	unset args builder varName sign reg

	# ensure valid state
	if [[ $action == "${SCRIPT_OPTS[defAction]}" && $# -gt 0 && ! ${SCRIPT_OPTS[defActionRep]} ]]; then
		log Error " - Default action must be used last, but was followed by: $*"
	fi
	[[ $actionArg && $# -eq 1 ]] && log Error " - Unexpected argument '$actionArg'"
	log Debug 'Params:' && for ((i = 0; i < sigN; i += 4)); do
		[[ ${!sigs[$i]} ]] && declare -p ${sigs[$i]} 1>&2
	done

	# cleanup and action call
	declare +n sigs
	unset sigs i sigN
	$action || log Warning ' failed!'
	local arg
	[[ $actionArg ]] && return 1 || return $((argc - $#))
}

call() { # for script usage - calling actions like itself with cli, without external process
	parseAction "$@"
	(($? == $# && logLvl > 2))
}

declare -A REGEX=(
	[var]='[0-9A-Za-z_]+' [dashvar]='[0-9A-Za-z_\-]+' [const]='[0-9A-Z_]+'
	[domain]='[a-z0-9]+\.[0-9a-z.]+'
)

#######################################
# Test if $reg matches $1, or the rest after parsing $reg == \$o.*; o = bash condexpr operator
# example: reg='$f\.txt' → matches any existing file with 'txt' extension, '$F' for just filename
# Arguments:
#   tested: input argument to be tested against the pattern
#   reg: required format of the argument
#######################################
argMatch() {
	local reg=${reg:-$2}
	if [[ $reg == '$'* ]]; then
		if [[ ${reg:1:1} == [Ee] ]]; then # any dir or file with given pattern
			[[ -d $1 ]] && return 0
			[[ ${reg:1:1} == e ]] && reg="\$f${reg:2}" || reg="\$F${reg:2}"
		fi
		[[ $1 =~ ^[^-][^=]*${reg:2}$ ]] && {
			if [[ ${reg:1:1} == F ]]; then
				[[ ! -d $1 ]]
			else
				eval [[ -${reg:1:1} \$1 ]]
			fi
		}
	else
		[[ $1 =~ ^$reg$ ]]
	fi
}

#######################################
# Print help about specified parameter from given action.
# Globals:
#   matcher: boolean
# Arguments:
#   action: string
#   paramIdx?: integer
#######################################
paramHelp() {
	local action=$1
	declare -n sig=${action}Params
	[[ $2 ]] && declare -i i=$2*4 end=i+4 || declare -i i=0 end=${#sig[@]}
	while ((i < end)); do
		local varName=${sig[$i]} sign=${sig[i + 1]} regex=${sig[i + 2]} help=${sig[i + 3]}
		if [[ $sign == ?[?*!+] ]]; then # option/arg non-positional
			[[ $sign == _? ]] && varName+=[] || varName+="[${sign::1}]"
			sign=${sign:1}
			[[ $regex ]] && sign+='<>' # no regex → toggle option
		elif [[ $sign == [?*!+] ]]; then
			sign+='<>'
		fi
		[[ $matcher -gt 0 && $regex ]] && help="/$regex/ $help"
		printf '    %-*s%s\n' $((ALIGNER + 4)) "$varName$sign: " "$help"
		i+=4
	done
}

actionInfo help 'display this help'
helpParams=(
	legend 'l?' '' 'Toggle legend for param notation (default=false)'
	matcher 'm?' '' 'Toggle regex matching argument (default=false)'
	params 'p?' '' 'Toggle params=opt+arg display (default=true)'
	actions '*' '[A-Za-z]+' 'Display help for action(s) (default=all)')
declare -A helpBuilder=([actions]=pickHelpAction)
pickHelpAction() {
	declare -n arr=$1
	arr=($(printf '%s\n' "${ACTION_ORDER[@]}" | fzf -m --prompt="$4: "))
}
help() {
	if [[ ! $actions ]]; then
		declare -n actions=ACTION_ORDER
		local default=true
		((SSS_OPTS[cli])) && echo "${SCRIPT_OPTS[about]}"
	fi
	((legend > 0)) && echo 'Legend:
  action: [a]ction
    - short name usage: in brackets, existence is optional
      - prefix with `-`
      - value immediately after or as the next arg (-aVal / -a val)
    - full name usage: can help distinguish next action from previous opts
      - prefix must match /'"${SCRIPT_OPTS[optPrefix]}"'/
      - value given with `=` or as the next arg (--act=val / --act val)
    - orderless (aside of repeated uses)
  option/orderless parameter: OPTION[o]? option[o]* opt[]=*
    - orderless parameters are required → `!` and `+` suffixes
    - like action, short name always appended in brackets (option[o])
    - type suffix: `<>` means option requires an argument
      - options represent toggles by default (`-o` → on, `+o` → off, chain: `+oO`)
      - can act as a toggle if accepts '' as an argument
    - quantifier suffix: see bellow
  positional parameter: name? name* name! name+
    - var name displayed for better referencing, can be used like long option
    - order matters (when unnamed); matched with regexes - list ended by first unmatched
    - required (`!`, `+`) or optional (`?`, `*`)
    - single arg (`?`, `!`) or a list of values (`*`, `+`)'

	[[ $default && ${#actions[@]} -gt 9 ]]
	declare -i params=${params:-$?}

	echo 'Actions:'
	local action
	for action in "${actions[@]}"; do
		((${#action} == 1)) && action=${ACTION_INFO[$action]}
		printf '  %-*s  %s\n' $ALIGNER "${ACTION_INFO[$action]%% *}" "${ACTION_INFO[$action]#* }"
		((params <= 0)) || paramHelp $action
	done
}

actionInfo quit 'exit the tui' # also called when exiting the cli
quit() {
	${SCRIPT_OPTS[exitFn]} 0 # override this for commit-before-exit
}

unknownParams=(received '+' '.*' 'consumes all remaining args to end execution')
unknown() {
	log Error " action '$received'!"
}

# Reads and sets matching value(s) from the user (all pickers must respect reg=$3)
pickAny() {
	if [[ $3 == '$'* ]]; then
		case "${3:2:1}" in
			e) pickFilesOrDir "$@" ;;
			d) pickDir "$@" ;;
			f) pickFile "$@" ;;
		esac
		return
	fi
	declare -ga $1
	declare -n _dst=$1
	while :; do
		local _pick=
		while [[ ! $_pick =~ ^$3$ ]]; do
			[[ $_pick ]] && echo "Argument has to match /$3/"
			read -rp "$4: " _pick
			[[ $_pick ]] || break
		done
		[[ $_pick ]] && _dst+=("$_pick")
		[[ $_pick && $2 == [+*] ]] || break
	done
}

pickDir() {
	local tmp=$(mktemp)
	ranger --choosedir="$tmp"
	if [[ -e $tmp ]]; then
		declare -n _choice=$1
		_choice="$(cat "$tmp")"
	fi
	rm "$tmp"
}

pickFile() {
	local tmp=$(mktemp)
	ranger --choosefile$([[ $2 == [+*] ]] && echo s)="$tmp"
	if [[ -e $tmp ]]; then
		mapfile -t $1 < "$tmp"
	fi
	rm "$tmp"
}

pickFilesOrDir() {
	[[ $2 == [+*] ]] && local _opts=(-m)
	_opts+=(--prompt "$4: " --preview 'ls {}')
	declare -n selected=$1
	local toView=(.)
	while :; do
		local f
		readarray -t _pick < <({
			echo '..'
			for f in "${toView[@]}"; do
				f=("$f"/*)
				printf '%s\n' "${f[@]}"
			done
		} | fzf "${_opts[@]}")

		if [[ -z $_pick ]]; then
			[[ -d $toView && $toView != '.' ]] && selected="$toView"
			break
		fi
		toView=()
		for f in "${_pick[@]}"; do
			if [[ -f $f ]]; then
				selected+=("$f")
			else
				toView+=("$f")
			fi
		done
		[[ ($selected && $2 != [+*]) || -z $toView ]] && break
	done
}

if [[ $0 == *sss ]]; then
	SCRIPT_OPTS[about]='SSS - A script simplifying scripting
Provides automatized param handling, arg parsing and basic autodoc.
Usage:
  1. Change SCRIPT_OPTS to suit your script.
  2. Source this script: `. sss`
  3. Register your actions
    `actionInfo <fName> <shortName>? <shortHighlight>? <fDescription>`
  4. Declare action opts/args, see `help` for meanings
    `<fName>Params=(<varName> <shortOpt/argSuffix> <argRegex> <description>)`
  5. Declare a mapping of arg names to picker functions for user arg selection (TUI use)
    `declare -A <fName>Builder=([<argName>]=<picker/selector fName>)`
  6. Picker gets full arg quaternion, saves selection to $1/argName
  7. Write your function.
  8?. for execution after configuration write an `execute/exec/run` action (with no required args)
      it should only print commands intended for execution if `SSS_OPTS[log]>0`
  9. Call `main "$@"` at the end of your script; set defAction for setup-then-exec use
There are a few predefined pickers and regexes you can use.'
	main "$@"
fi
