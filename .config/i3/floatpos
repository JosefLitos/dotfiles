#!/usr/bin/env bash
# shellcheck disable=2086
#i3/floatpos -i3 floating mode tiling functionality similar to Windows
# Made by Kepis, enjoy your linux i3floatingWM setup

p2="$2"
#for usage in tiling mode
if [[ $(xprop -id "$(xdotool getactivewindow)" I3_FLOATING_WINDOW) != I3_FLOATING*1 ]]; then
	if [[ $p2 == "shift" ]]; then
		case "$1" in
			"up") i3 focus up ;;
			"down") i3 focus down ;;
			"left") i3 focus left ;;
			"right") i3 focus right ;;
		esac
	else
		case "$1" in
			"up") i3 move up ;;
			"down") i3 move down ;;
			"left") i3 move left ;;
			"right") i3 move right ;;
			"c") i3 split h,layout tabbed ;;
		esac
	fi
	exit 0
fi

# autodetection for bar size and position + screen dimensions
declare -i dim=(0 0 0 0) # W, H, W/2, H/2
while read -a line; do
	case "${line[0]}${line[2]}" in
		"AbsoluteY:") bottom=${line[-1]} ;;
		"Height:") bar=${line[-1]} ;;
		"MapIsUnMapped") nobar=1 ;;
		"Width:") dim[0]=${line[1]} ;;
		"Corners:"*) ((bottom != 0)) && dim[1]=bottom+nobar*bar || dim[1]=${line[3]#-0-}+nobar*bar ;;
	esac
done <<< $(xwininfo -id $(xdotool search --class "i3bar"))

# available width and height
[[ $nobar == 1 || $bottom != 0 ]] && Y=0 || Y=$bar
((dim[2] = dim[0] / 2))
((dim[3] = dim[1] / 2))
declare -i Y2=dim[1]/2+Y

# window border
[[ -z $border ]] && border=2

# get windetails using sed
declare -i win=($(xwininfo -id $(xdotool getactivewindow) | sed -n \
	-e "s/^ \+Absolute upper-left X: \+\([0-9]\+\).*/\1/p" \
	-e "s/^ \+Absolute upper-left Y: \+\([0-9]\+\).*/\1/p" \
	-e "s/^ \+Width: \+\([0-9]\+\).*/\1/p" \
	-e "s/^ \+Height: \+\([0-9]\+\).*/\1/p"))

win[0]+=-border  # X
win[1]+=-border  # Y
win[2]+=border*2 # width
win[3]+=border*2 # height

#Setts window to quarter of the screen and centers it
defsize() {
	i3 resize set ${dim[2]} ${dim[3]}, move position center
}

#Manages 'up' action
up() {
	if [[ $p2 == shift ]]; then
		i3 move position ${win[0]} $Y
	elif ((win[1] <= Y)); then
		if ((win[3] > dim[3])); then
			i3 resize set height ${dim[3]}
		else
			i3 move position 0 $Y, resize set ${dim[0]} ${dim[1]}
		fi
	elif ((win[1] + win[3] >= Y + dim[1])); then
		if ((win[2] > dim[0] * 5 / 7)); then
			defsize
		elif ((win[3] <= dim[1] * 3 / 5)); then
			i3 move position ${win[0]} $Y, resize set height ${dim[1]}
		else
			i3 move position ${win[0]} $Y, resize set height ${dim[3]}
		fi
	else
		i3 move position ${win[0]} $Y
	fi
}

#Manages 'down' action
down() {
	if [[ $p2 == shift ]]; then
		i3 move position ${win[0]} $((Y + dim[1] - win[3]))
	elif ((win[1] <= Y)); then
		if ((win[2] > dim[0] * 5 / 7)); then
			defsize
		elif ((win[3] == dim[1])); then
			i3 move position ${win[0]} $Y2, resize set height ${dim[3]}
		else
			i3 resize set height ${dim[1]}
		fi
	elif ((win[1] + win[3] >= Y + dim[1])); then
		i3 move position 0 $Y2, resize set ${dim[0]} ${dim[3]}
	else
		i3 move position ${win[0]} $((Y + dim[1] - win[3]))
	fi
}

#Manages 'left' action
left() {
	if [[ $p2 == shift ]]; then
		i3 move position 0 ${win[1]}
	elif ((win[0] == 0 && win[2] <= dim[0] * 5 / 7)); then
		i3 move position $((dim[0] - win[2])) ${win[1]}
	elif ((win[0] > dim[0] * 3 / 7)); then
		defsize
	else
		i3 move position 0 $Y, resize set ${dim[2]} ${dim[1]}
	fi
}

#Manages 'right' action
right() {
	if [[ $p2 == shift ]]; then
		i3 move position $((dim[0] - win[2])) ${win[1]}
	elif ((win[0] + win[2] == dim[0] && win[2] <= dim[0] * 5 / 7)); then
		i3 move position 0 ${win[1]}
	elif ((win[0] + win[2] <= dim[0] * 4 / 7)); then
		defsize
	else
		i3 move position ${dim[2]} $Y, resize set ${dim[2]} ${dim[1]}
	fi
}

case "$1" in
	"up") up ;;
	"down") down ;;
	"left") left ;;
	"right") right ;;
	"c") i3 move position center ;;
esac
